<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通知</title>
      <link href="/14514/11/14/%E9%80%9A%E7%9F%A5/"/>
      <url>/14514/11/14/%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="hczchat">hczchat</h2><p>hczchat上线了,不要滥用</p><h2 id="网盘反馈">网盘反馈</h2><p>在下方反馈区反馈</p><h2 id="征集文章">征集文章</h2><p>如果想要在这个网站网上自己文章的话,可以线下找hcz或在下面评论区(部分时候会关闭)或在luogu找huchangzhi</p><h2 id="留言">留言</h2><p>留言可在文章下方留言</p>]]></content>
      
      
      
        <tags>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假作业完成进度</title>
      <link href="/2025/07/13/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E5%AE%8C%E6%88%90%E8%BF%9B%E5%BA%A6/"/>
      <url>/2025/07/13/%E6%9A%91%E5%81%87%E4%BD%9C%E4%B8%9A%E5%AE%8C%E6%88%90%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><a href="/temp.html">点我</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩笔记</title>
      <link href="/2025/06/13/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/13/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="状态压缩小结">状态压缩小结</h1><button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><h2 id="一般的dp">一般的DP</h2><p><strong>最长公共子序列</strong> <span class="math inline">\(f_{i,j}\)</span>表示<span class="math inline">\(a_{1 \to i}\)</span>和<spanclass="math inline">\(b_{1 \to j}\)</span>的最长公共子序列  </p><p><strong>背包</strong> <span class="math inline">\(f_{i,j}\)</span>表示前<spanclass="math inline">\(i\)</span>个物品选一些，总体积为<spanclass="math inline">\(j\)</span>时的最大价值</p><p>但当问题变得很复杂,有<spanclass="math inline">\(n\)</span>个不同的属性<del>那么就多开几维,大力出奇迹</del>,就需要<strong>状态压缩</strong>了</p><h2 id="状态压缩">状态压缩</h2><p>举个🌰(栗子) </p><h3 id="题目">题目</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n个人玩传球游戏：球可以从任何一个人开始传，每次传给一个还没有接到过球的人，接到球的人继</span><br><span class="line">续传给另一个没有接到过球的人，当所有人都接到过球之后就结束。</span><br><span class="line">任意两个人之间传球都有一定的代价，不同人之间传球的代价可能不相同。求传球游戏结束后的最小总代价。</span><br><span class="line">数据范围：n≤16</span><br></pre></td></tr></table></figure><p>用搜索是可以过的,但要记忆化,然而这篇小结是状态压缩</p><h4 id="dp做法">DP做法</h4><p>设<span class="math inline">\(n\)</span>个人的编号是<spanclass="math inline">\(0,1,\dotsi,n-1\)</span>  </p><p><span class="math inline">\(f_{S,i}\)</span>表示<spanclass="math inline">\(S\)</span>集合中的人已经接过球,且当前球在第<spanclass="math inline">\(i\)</span>个人手中的最小总代价</p><p><strong>状态转移</strong></p><p>算<span class="math inline">\(f_{S,i}\)</span>时,枚举传球给<spanclass="math inline">\(i\)</span>的人<spanclass="math inline">\(j\)</span>,<strong><spanclass="math inline">\(S\)</span>二进制的<spanclass="math inline">\(2𝑗\)</span>位必须是1</strong></p><p><span class="math inline">\(f_{S-2^i,j} + cost_{j,i}\tof_{S,i}\)</span></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S = <span class="number">0</span>;S &lt; <span class="number">1</span> &lt;&lt; N;S++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        f[S][i] = <span class="number">1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    f[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//状态转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S = <span class="number">2</span>;S&lt;<span class="number">1</span>&lt;&lt;N;S++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; (S &gt;&gt; j &amp; <span class="number">1</span>))&#123;</span><br><span class="line">                    f[S][i] = <span class="built_in">min</span>(f[S][i], f[S ^ <span class="number">1</span> &lt;&lt; i][j] + cost[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, f[(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th>题目</th><th>解法</th><th>易错点</th></tr></thead><tbody><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=K">K.过桥</a></td><td><span class="math inline">\(S\)</span>的第<spanclass="math inline">\(i\)</span>位为1表示第<spanclass="math inline">\(i\)</span>位队员已过桥。</td><td></td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=N">N.送外卖</a></td><td><span class="math inline">\(f_{S,i}\)</span>: 表示已经访问了集合<span class="math inline">\(S\)</span> 中表示的城市，且当前在城市 <spanclass="math inline">\(i\)</span> 的最小时间</td><td>需要使用<spanclass="math inline">\(Floyd\)</span>预处理所有点对之间的最短路径</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=O">O.单词游戏</a></td><td><span class="math inline">\(f_{S,i}\)</span>:表示当前已经使用的单词集合是 <spanclass="math inline">\(S\)</span>，并且最后一个使用的是第 <spanclass="math inline">\(i\)</span>个单词时的最大价值,calc_cost计算重叠部分</td><td>许多细节,详见下方</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=P">P.玉米地</a></td><td><span class="math inline">\(f_{i, S}\)</span> 表示处理到第 <spanclass="math inline">\(i\)</span> 行，且第 <spanclass="math inline">\(i\)</span> 行状态为 <spanclass="math inline">\(S\)</span> 的方案数</td><td><span class="math inline">\(MODMODMOD\)</span>!!!!!</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=Q">Q.慢跑小路</a></td><td>要满足“每条边至少走一遍，且起点等于终点”，需要构造一个欧拉回路</td><td>需要<spanclass="math inline">\(Floyd\)</span>预处理<del>好眼熟</del>,详见下方</td></tr></tbody></table><h4 id="部分例题详解">部分例题详解</h4><h5 id="o.单词游戏"><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=O">O.单词游戏</a></h5><p>需要一个calc_cost计算重叠部分 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc_cost</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len_a = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len_b = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">12</span>][<span class="number">12</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_a; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len_b; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    f[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还要预处理存下来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        cost[i][j] = <span class="built_in">calc_cost</span>(dc[i], dc[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="q.慢跑小路"><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3311&amp;tid=Q">Q.慢跑小路</a></h5><p>需要统计奇度数节点 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">16</span>], js = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span> (deg[i]%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        p[js++] = i;</span><br></pre></td></tr></table></figure></p><p>注意结果输出还要加边的总长<code>printf("%d\n", edge+f[(1&lt;&lt;js)-1]);</code></p><p>还有多组数据的初始化</p><p><code>memset(deg,0,sizeof(deg));</code></p><p><code>memset(f,0x3f,sizeof(f));</code></p><p><del>不会有人就错在这里吧 :)</del></p><p><span class="math inline">\(THE\)</span> <spanclass="math inline">\(END\)</span>,作者:<spanclass="math inline">\(Hcz\)</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组与线段树</title>
      <link href="/2025/05/25/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2025/05/25/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者 <ahref="https://www.luogu.com.cn/user/1368090">ny_123457</a></p></blockquote><button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><p><strong>注：如果图片太小看不太清，hcz建议可以点击图片放大。</strong></p><h2 id="part-1.树状数组">Part 1.树状数组</h2><p>首先这个东西真的巨好用，它是利用数的二进制特征进行检索的一种树状结构，<del>（虽然它模版绿）</del>，代码很短，仅需三个函数就可以实现单点修改，区间查询（区间求和），效率也很高。</p><p><del>接下来介绍树状数组是个什么玩意。</del></p><p>它都叫树状数组了，肯定要搞一棵树啊，假设我们有一个数列，然后问你一堆诸如求一个区间的最值或求区间和的问题，数据范围还很大，请问你怎么办？<del>暴力怼上去啊，能骗几分骗几分。</del>（考场上实在没办法了才打暴力。）</p><p>这时候就可以写树状数组了（其实针对这个题也可以写后面才讲的线段树，但是线段树码量太大了，还是建议写树状数组），我们先设定有两个数组，<spanclass="math inline">\(A\)</span> 数组和 <spanclass="math inline">\(C\)</span> 数组，其中 <spanclass="math inline">\(A\)</span> 数组为我们输入的数组，<spanclass="math inline">\(C\)</span> 数组需要我们自行计算。</p><p><span class="math inline">\(C\)</span> 数组的计算如下：<br /><span class="math inline">\(C_1=A_1\)</span><br /><span class="math inline">\(C_2=A_1+A_2\)</span><br /><span class="math inline">\(C_3=A_3\)</span><br /><span class="math inline">\(C_4=A_1+A_2+A_3+A_4\)</span><br /><span class="math inline">\(C_5=A_5\)</span><br /><span class="math inline">\(C_6=A_5+A_6\)</span><br /><span class="math inline">\(C_7=A_7\)</span><br /><span class="math inline">\(C_8=A_1+A_2+A_3+ \cdots +A_8\)</span><br /><span class="math inline">\(\cdots\)</span></p><p>等等，它不是一种用二进制特征进行检索的树状数据结构吗？这跟二进制有什么联系？（阅读本文时建议先思考这个问题在往下读）</p><figure><img src="https://s2.loli.net/2025/05/25/ykH6d9ZclYB7LMb.png"alt="114514.PNG" /><figcaption aria-hidden="true">114514.PNG</figcaption></figure><p>把 <span class="math inline">\(C\)</span> 数组转化为递推表达式就是<span class="math inline">\(C_i=A_{2^k+1}+ \cdots +A_i\)</span>。其中<span class="math inline">\(k\)</span> 为 <spanclass="math inline">\(i\)</span> 对应的二进制数末尾 <spanclass="math inline">\(0\)</span> 的个数，<spanclass="math inline">\(i\)</span> 从 <spanclass="math inline">\(1\)</span> 开始计算，但是问题又来了，知道 <spanclass="math inline">\(i\)</span> 怎么求 <spanclass="math inline">\(2^k\)</span>？我们 C++代码中的与运算能够很好的解决这个问题，将答案写入代码中就是<code>i&amp;(-i)</code>（不了解位运算的建议去翻别人的博客学习一下）。</p><p>于是，我们的第一个函数就诞生了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再来思考关于求和的问题，当我们求 <spanclass="math inline">\(A_1+A_2+ \cdots +A_x\)</span> 的之和时，<spanclass="math inline">\(C_x\)</span> 如果包含的不一定是 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(x\)</span> 的全部和（比如 <spanclass="math inline">\(C_6=A_5+A_6\)</span>） 就需要再找一个 <spanclass="math inline">\(C_k\)</span>（显然 <spanclass="math inline">\(k&lt;x\)</span>）累加起来，这个 <spanclass="math inline">\(k\)</span> 我们称之为 <spanclass="math inline">\(x\)</span> 的前驱，例如:</p><p><span class="math inline">\(A_1+A_2+ \cdots+A_6=C_6+C_4\)</span><br /><span class="math inline">\(A_1+A_2+ \cdots+A_7=C_7+C_6+C_4\)</span></p><p>前驱的编号：比自己小的，最近的，最末连续 <spanclass="math inline">\(0\)</span> 比自己多的数（在二进制下）。</p><p>所以设 <span class="math inline">\(x\)</span> 的前驱为 <spanclass="math inline">\(k\)</span>，则 <code>k=x-lowbit(x)</code>，相当于<span class="math inline">\(x\)</span> 减掉了自己最右边的 <spanclass="math inline">\(1\)</span>。</p><p>所以，我们的第二个用于求和的函数诞生了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=x;k&gt;<span class="number">0</span>;k-=<span class="built_in">lowbit</span>(k))sum+=c[k];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">这个只能用于求从 $<span class="number">1</span>$ 到 $x$ 项的和，如果要求区间和，假设是区间 $[x,y]$，则这个区间的区间和就为 ```<span class="built_in">getsum</span>(y)-<span class="built_in">getsum</span>(x<span class="number">-1</span>)```。（减一是因为 $A_x$ 也是算入这个区间的。）</span><br><span class="line"></span><br><span class="line">然后就是剩下的单点修改了，还是前面放的那个图，如果修改了某个 $A_i$ 那么所有跟这个 $A_i$ 相关的 $C_i$ 就也全部需要修改，翻译成人话就是更改从该叶子节点到根节点路径上的所有 $C_i$。这里的父亲节点就是比自己大的，最近的，二进制下末尾 $<span class="number">0</span>$ 的数量最多的数，所以 $x$ 节点的父亲节点的编号就是 ```x+<span class="built_in">lowbit</span>(x)```。</span><br><span class="line"></span><br><span class="line">单点修改函数如下：  </span><br><span class="line"></span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))c[i]+=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一看，我滴妈呀，时间复杂度仅为 <span class="math inline">\(O(\logn)\)</span>，所以一般情况下能写树状数组就写树状数组（单纯想练习线段树的除外）。</p><p><strong>然后恭喜你已学会树状数组的基本操作！</strong></p><h2 id="part-2.线段树">Part 2.线段树</h2><p>该来的还是来了。这个东西和树状数组很像，但是它比树状数组多支持了个区间修改和区间查询，效率也很高，但有个很无语的缺点：<strong>码量太大了</strong>，动不动就一百多行的，这也就意味着很难调，考场遇到了如果时间不那么充足就建议直接打个暴力上去，线段树的题暴力分一般会比较高。</p><p>线段树是一种特殊的二叉树，它可以将一个线性的序列组织成一个树状结构，从而可以在对数的时间复杂度下访问序列上的任意一个区间并进行维护，在线段树中，每一个节点要么没有子节点，有么就有两个子节点，其中每一个节点记录的都是一个区间和或一个区间的最值，一个父亲节点的值就为它的两个儿子节点的值的合并体，举个例子，如果这个节点的子节点记录的分别是区间<span class="math inline">\([1,3]\)</span> 和区间 <spanclass="math inline">\([4,5]\)</span>的和（或最值），它们的父亲节点记录的就是区间 <spanclass="math inline">\([1,5]\)</span>的和（或最值），线段树支持单点修改，区间修改，单点查询，区间查询。</p><p>下面的图片所呈现的就是一个合法的线段树：</p><figure><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/tujkvxrd.png?x-oss-process=image/resize,m_lfit,h_170,w_225"alt="logo" /><figcaption aria-hidden="true">logo</figcaption></figure><p>若一个节点的编号为 <spanclass="math inline">\(x\)</span>，那么它的子节点的编号就分别为 <spanclass="math inline">\(2 \times x\)</span> 与 <spanclass="math inline">\(2 \times x+1\)</span>。<del>二叉树常识都知道的吧。</del></p><p>一些线段树的性质：<br />- 长度为 <span class="math inline">\(n\)</span>的序列建的线段树，节点个数为 <span class="math inline">\(2n-1\)</span>。- 长度为 <span class="math inline">\(n\)</span>的序列建的线段树，树深度为 <spanclass="math inline">\(\log(n)\)</span>。 -线段树需要维护的东西一定具有可合并性。</p><p>接下来就可以想想怎么建树了，上文说了，一个节点表示的是一个区间的数据，因此一个节点要至少三个数据，分别是左端点，右端点和区间数据（如果有区间修改这种高级操作那么就还需要一个懒标记，作用后文会提到）由于这是一颗二叉树，而我们输入的是一个序列，因此空间需要开四倍。</p><p>接下来就可以写合并和建树的函数了，首先合并的题目给啥合并啥，比如求和的那么当前节点的区间数据即为它两个儿子的区间数据的和，最值即为它两个儿子的区间数据的最值。建树就可以用递归（和DFS的思路差不多）进行，一直往下推，如果当前节点的左端点与右端点重合（区间仅为这单独的一个点），那么这个节点的区间数据即为这个单独的点的值，单点建树时间复杂度同样为<span class="math inline">\(O(\log(n))\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">lilaoshi</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,val;</span><br><span class="line">&#125;tree[<span class="number">4</span>*maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p].val=tree[<span class="number">2</span>*p].val+tree[<span class="number">2</span>*p<span class="number">+1</span>].val;</span><br><span class="line">&#125;<span class="comment">//这里以求和为例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">tree[p].l=x;</span><br><span class="line">tree[p].r=y;</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">tree[p].val=a[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(x+y)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,x,mid);</span><br><span class="line"><span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,y);</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就该考虑单点修改操作了，可以先设一个需要改变的值，然后就是需要改变的数和当前改变的数的编号，然后就是与<code>build</code>函数一样的思想，先往下递归，如果这是一个单点区间，那么就直接更改该节点的区间数据，否则就二分下去查找（遍历自己的两个儿子），时间复杂度（单点修改）同样为<span class="math inline">\(O(\log(n))\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].l==tree[p].r)&#123;</span><br><span class="line">tree[p].val+=d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=tree[p&lt;&lt;<span class="number">1</span>].r)<span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>,k,d);</span><br><span class="line"><span class="keyword">if</span>(k&gt;=tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k,d);</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是区间求和和最值了，首先假设我们要找的区间为 <spanclass="math inline">\([l,r]\)</span>，当前所遍历到的区间为 <spanclass="math inline">\([x,y]\)</span>，如果这两个区间八竿子打不着（没有相交）就可以直接跳过了（看情况，求和返回<spanclass="math inline">\(0\)</span>，求最值返回一个很大或很小的数），如果<span class="math inline">\([l,r]\)</span> 完全包含 <spanclass="math inline">\([x,y]\)</span>，那么直接返回被包含的区间数据，反正都要求了先把部分搞出来在搞全部也可以，如果有相交的地方就接着遍历左右儿子，总有整个区间都被包含的，时间复杂度又双叕叕是<span class="math inline">\(O(\log(n))\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&lt;tree[p].l||s&gt;tree[p].r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(s&lt;=tree[p].l&amp;&amp;tree[p].r&lt;=t)<span class="keyword">return</span> tree[p].val;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getsum</span>(p&lt;&lt;<span class="number">1</span>,s,t)+<span class="built_in">getsum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,s,t);</span><br><span class="line">    <span class="comment">//求最值：return max/min(getsum(p&lt;&lt;1,s,t),getsum(p&lt;&lt;1|1,s,t));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某邪恶的何老板：都这样了，那我不让你去求区间数据，让你求修改完的单点数据怎么办？这还不简单，从根节点开始一直二分遍历自己的所有儿子，总有一个儿子是只包含这一个点的，时间复杂度……传奇<span class="math inline">\(O(\log(n))\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].l==tree[p].r)<span class="keyword">return</span> tree[p].val;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=tree[p&lt;&lt;<span class="number">1</span>].r)<span class="keyword">return</span> <span class="built_in">getval</span>(p&lt;&lt;<span class="number">1</span>,k);</span><br><span class="line"><span class="keyword">if</span>(k&gt;=tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l)<span class="keyword">return</span> <span class="built_in">getval</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就该是区间修改了: -在区间修改时，显然不能暴力地修改每个叶子，那样效率很低。 -为此，引入延迟标记（又称为懒标记或者<code>lazy</code>），记录一些区间修改的信息。 -当递归至一个被完全包含的区间时，在这个区间上打一个延迟标记，记录这个区间中的每个数都需要被加上某个数，然后直接修改该结点的区间和并返回，不再向下递归（省时）。-当新访问到一个结点时，先将延迟标记下放到子结点结点，然后再进行递归。</p><p>简而言之：<br />如果需要对一个区间中每一个叶结点进行操作，我们不妨先别忙着操作，而是在所有大区间上做一个标记，下一次遇到或要用到时，再进行处理（标记传递）。</p><p>具体的例子可以通过下面的图片来了解一下。<br /><img src="https://s2.loli.net/2025/05/25/J8DUqNZseFnlCc2.png"alt="2.PNG" /></p><p>但是懒标记有的时候可能修改完了都还没有分下去，于是我们再求答案时也需要再下放一次懒标记。</p><p>至于代码部分，区间修改的代码相较于单点修改差不多，就是在更改这一节点是也一起更改懒标记，更新懒标记直接二分模拟，下发懒标记同样模拟，但要注意，只有在这个懒标记的值不为<span class="math inline">\(0\)</span> 时才能下发，时间复杂度……<spanclass="math inline">\(O(\log(n))\)</span> <del>得了 MVP</del>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void maketag(int p,int len,int x)&#123;</span><br><span class="line">tree[p].lazy+=x;</span><br><span class="line">tree[p].val+=x;</span><br><span class="line">&#125;</span><br><span class="line">void pushdown(int p)&#123;</span><br><span class="line">int M=tree[p].r+tree[p].l&gt;&gt;1;</span><br><span class="line">maketag(p&lt;&lt;1,M-tree[p].l+1,tree[p].lazy);</span><br><span class="line">maketag(p&lt;&lt;1|1,tree[p].r-M,tree[p].lazy);</span><br><span class="line">tree[p].lazy=0;</span><br><span class="line">&#125;</span><br><span class="line">void tag(int u)&#123;</span><br><span class="line">if(tree[u].lazy)&#123;</span><br><span class="line">int d=tree[u].lazy;</span><br><span class="line">tree[u].lazy=0;</span><br><span class="line">tree[u&lt;&lt;1].lazy+=d;</span><br><span class="line">tree[u&lt;&lt;1].val+=d;</span><br><span class="line">tree[u&lt;&lt;1|1].lazy+=d;</span><br><span class="line">tree[u&lt;&lt;1|1].val+=d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void add(int p,int x,int y,int d)&#123;</span><br><span class="line">if(x&lt;=tree[p].l &amp;&amp; tree[p].r&lt;=y)&#123;</span><br><span class="line">tree[p].val+=d;</span><br><span class="line">tree[p].lazy+=d;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tag(p);</span><br><span class="line">int mid=tree[p].l+tree[p].r&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid) add(p&lt;&lt;1,x,y,d);</span><br><span class="line">if(y&gt;mid) add(p&lt;&lt;1|1,x,y,d);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="part-3.动态开点线段树">Part 3.动态开点线段树</h2><p>先讲一个故事：有一天，我正在亲亲苦苦的刷线段树的题，看到一个题我觉得像模版就应该不难，然后数组<span class="math inline">\(10^5\)</span>不想改了，正常写完交上去硬控我三分钟。</p><figure><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/vzv5lc8i.png?x-oss-process=image/resize,m_lfit,h_170,w_225"alt="logo" /><figcaption aria-hidden="true">logo</figcaption></figure><p>后来一看数据……</p><figure><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/6t9urdzl.png?x-oss-process=image/resize,m_lfit,h_170,w_225"alt="logo" /><figcaption aria-hidden="true">logo</figcaption></figure><p><span class="math inline">\(10^9\)</span>的数据空间太大了，肯定不能用普通线段树去做，而这个问题有做多只会有 <spanclass="math inline">\(5 \times 10^5\)</span>的操作次数。因此，动态开点线段树就可以完成这个问题。</p><p>首先朴素线段树的建树是每一个节点都要建，这样很费空间，动态开点线段树是要用到的节点才建树，举个例子，当前遍历到了节点<span class="math inline">\(x\)</span>，则 <spanclass="math inline">\(x\)</span>的所有祖宗节点都需要建，其他点就不用。</p><p>翻译成人话：线段树动态开点的意思是一开始不用建立树，当我们在进行操作过程中，发现需要走到一个节点时，如果这个节点还没建立，我们才建立这个节点。</p><p>动态开点的作用是节约空间，避免离散化，时间复杂度同朴素线段树。</p><p>下图就是一个例子：<br /><img src="https://s2.loli.net/2025/05/25/4nBLKseSpqilIQz.png"alt="3.PNG" /></p><p>至于代码部分，由于每次构建的节点不像线段树一样有一个固定的编号，因此需要自己设立一个变量来记录当前遍历到的节点的编号，其余部分同朴素线段树，本文用<span class="math inline">\(tot\)</span> 来表示节点的编号，注意：<spanclass="math inline">\(tot\)</span> 需要初始化为 <spanclass="math inline">\(1\)</span>，首个需自行建立的节点计算时编号为 <spanclass="math inline">\(2\)</span> 编号为 <spanclass="math inline">\(1\)</span> 的节点为根节点。</p><p><strong>细节：使用动态开点线段树是为了节省空间，因此数组无需开四倍。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,ans,tot=<span class="number">1</span>,ls[maxn*<span class="number">4</span>],rs[maxn*<span class="number">4</span>],lazy[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">lazy[p]=<span class="built_in">max</span>(lazy[p],d);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid)&#123;</span><br><span class="line"><span class="keyword">if</span>(ls[p]==<span class="number">0</span>)ls[p]=++tot;</span><br><span class="line"><span class="built_in">add</span>(ls[p],l,mid,x,y,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;y)&#123;</span><br><span class="line"><span class="keyword">if</span>(rs[p]==<span class="number">0</span>)rs[p]=++tot;</span><br><span class="line"><span class="built_in">add</span>(rs[p],mid<span class="number">+1</span>,r,x,y,d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls[p])lazy[ls[p]]=<span class="built_in">max</span>(lazy[ls[p]],lazy[p]);</span><br><span class="line"><span class="keyword">if</span>(rs[p])lazy[rs[p]]=<span class="built_in">max</span>(lazy[rs[p]],lazy[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="built_in">putdown</span>(p);</span><br><span class="line"><span class="keyword">if</span>(l==r)<span class="keyword">return</span> lazy[p];</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ls[p])sum+=<span class="built_in">getans</span>(ls[p],l,mid);</span><br><span class="line"><span class="keyword">else</span> sum+=lazy[p]*(mid-l<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">if</span>(rs[p])sum+=<span class="built_in">getans</span>(rs[p],mid<span class="number">+1</span>,r);</span><br><span class="line"><span class="keyword">else</span> sum+=lazy[p]*(r-mid);</span><br><span class="line"><span class="keyword">return</span> sum;<span class="comment">//依旧以求和为例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完结撒花">完结撒花！</h2><h2 id="inf.鸣谢">inf.鸣谢</h2><p>感谢 lijing2020 的教学与精神支持！<br />感谢 Huchangzhi 的课件记录！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST表，LCA，线段树笔记</title>
      <link href="/2025/05/19/ST%E8%A1%A8%EF%BC%8CLCA%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/05/19/ST%E8%A1%A8%EF%BC%8CLCA%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="st表lca线段树-笔记">ST表，LCA，线段树 笔记</h1>作者：<span class="math inline">\(hcz\)</span><button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><h2 id="st表">ST表</h2><h3 id="基本原理">基本原理</h3><p>在求区间最值时，若一个大区间若能被两个小区间覆盖，那么大区间的最值等于两个小区间的最值。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/xxqrk0u9.png" /></p><p>如图</p><h3 id="步骤">步骤</h3><p><strong>1. 把数列按倍增分成小区间</strong></p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/v8c1dlbp.png" /></p><p>如图，直接明了</p><p><strong>2. 查询任意区间的最值</strong></p><p>把需查询区间 <span class="math inline">\([l, r]\)</span>分为两个区间，且两区间同属一组：</p><ul><li>以 <span class="math inline">\(L\)</span> 为起点的小区间</li><li>以 <span class="math inline">\(R\)</span> 为终点的小区间</li></ul><p>这两个小区间首尾相接覆盖 <span class="math inline">\([L,R]\)</span></p><h3 id="实现">实现</h3><p><span class="math inline">\(f[i][j]\)</span> 表示从第 <spanclass="math inline">\(i\)</span> 个位置开始，长度为 <spanclass="math inline">\(2^j\)</span> 的区间的最大值。</p><h4 id="预处理">预处理</h4><p><span class="math display">\[ f[i][0] = a[i] \]</span></p><p><span class="math display">\[ f[i][j] = \max(f[i][j-1], f[i +2^{j-1}][j-1]) \]</span></p><h4 id="查询">查询</h4><p>查 <span class="math inline">\([l, r]\)</span> 先找到最大的满足 <spanclass="math inline">\(2^j \le r - l + 1\)</span> 的 <spanclass="math inline">\(j\)</span></p><p><span class="math display">\[ j = \lfloor \log_2(r - l + 1) \rfloor\]</span></p><p>区间最值为：</p><p><span class="math display">\[ \max(f[l][j], f[r - 2^j + 1][j])\]</span></p><h4 id="模板">模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; f[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line">k = <span class="built_in">log2</span>(n);</span><br><span class="line"><span class="keyword">for</span>(j:<span class="number">1</span>--k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i:<span class="number">1</span>--(n-(<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)) )&#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j<span class="number">-1</span>], f[i+(<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i][j] = f[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="comment">//查l--r的最值</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">max</span>(f[l][j], f[r - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure><h4 id="例题">例题</h4><h5 id="b---rmq奶牛探洞-cqnk"><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=B">B- 【RMQ】奶牛探洞 | CQNK</a></h5><p>十分典型的一道 RMQ 问题，计算最小值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">log2</span>(n);j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);i++)&#123;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j<span class="number">-1</span>], f[i+(<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i][j] = f[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">min</span>(f[l][j], f[r - (<span class="number">1</span> &lt;&lt; j)<span class="number">+1</span>][j]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lca">LCA</h2><p>求最近公共祖先。</p><h3 id="步骤-1">步骤</h3><ul><li>求 <span class="math inline">\(u,v\)</span> 的最近公共祖先</li><li>调整 <span class="math inline">\(u,v\)</span> 至同一高度</li></ul><p>如果 <span class="math inline">\(\text{depth}[u] &gt;\text{depth}[v]\)</span>，将 <span class="math inline">\(u\)</span>向上跳 <span class="math inline">\(s = \text{depth}[u] -\text{depth}[v]\)</span> 步，用倍增方式实现。</p><p>当 <span class="math inline">\(u,v\)</span>高度相同后，再“试着”继续上跳：</p><ul><li>设 <span class="math inline">\(k = \lfloor \log_2(\text{height})\rfloor\)</span></li><li>尝试跳 <span class="math inline">\(2^k\)</span> 步，若 <spanclass="math inline">\(f[u][k] \ne f[v][k]\)</span> 则跳</li><li>尝试跳 <span class="math inline">\(2^{k-1}\)</span> 步...</li><li>直到跳 <span class="math inline">\(2^0\)</span> 步</li></ul><h3 id="模板-1">模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;g[u].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        d[v] = d[u]<span class="number">+1</span>;</span><br><span class="line">        anc[v][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[u] &lt; d[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(n); i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[anc[u][i]] &gt;= d[v])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log2</span>(n); i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(anc[u][i] != anc[v][i])&#123;</span><br><span class="line">            u = anc[u][i];</span><br><span class="line">            v = anc[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="comment">// 输入u, v</span></span><br><span class="line">    g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    fq[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m; </span><br><span class="line"><span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fq[i])&#123;</span><br><span class="line">        s = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">d[s] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="built_in">log2</span>(n); j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        anc[i][j] = anc[anc[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="comment">//输入u, v</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(u, v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树">线段树</h2><p>可以实现在需要区间修改时高效处理（最值/和/异或.......）</p><p>线段树是一种特殊的二叉树，它可以将一个线性的序列组织成一个树状结构，从而可以在对数的时间复杂度下访问序列上的任意一个区间并进行维护。</p><p>对于编号为 <span class="math inline">\(i\)</span> 的节点 <spanclass="math inline">\(Tree[i]\)</span>：</p><ul><li>父亲为 <span class="math inline">\(Tree[i / 2]\)</span></li><li>左子树为 <span class="math inline">\(Tree[i*2]\)</span></li><li>右子树为 <span class="math inline">\(Tree[i*2+1]\)</span></li></ul><h3id="模板区间修改与查询这里以区间求和为例">模板（区间修改与查询,这里以区间求和为例）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz[MAX_N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> lazy;</span><br><span class="line">&#125; Tree[<span class="number">4</span> * MAX_N];</span><br></pre></td></tr></table></figure><p><strong>左右节点求和</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    Tree[p].val = Tree[<span class="number">2</span>*p].val + Tree[<span class="number">2</span>*p<span class="number">+1</span>].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>建树</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeTree</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    Tree[p].l = x;</span><br><span class="line">    Tree[p].r = y;</span><br><span class="line">    <span class="keyword">if</span>(x == y) &#123;</span><br><span class="line">        Tree[p].val = sz[x];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (x+y) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MakeTree</span>(p &lt;&lt; <span class="number">1</span>, x, mid);</span><br><span class="line">    <span class="built_in">MakeTree</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid<span class="number">+1</span>, y);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>懒标记</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Maketag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> len, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    Tree[p].lazy += x;</span><br><span class="line">    Tree[p].val += len * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>下放懒标记</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> M = (Tree[p].r + Tree[p].l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Maketag</span>(p &lt;&lt; <span class="number">1</span>, M - Tree[p].l + <span class="number">1</span>, Tree[p].lazy);</span><br><span class="line">    <span class="built_in">Maketag</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, Tree[p].r - M, Tree[p].lazy);</span><br><span class="line">    Tree[p].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>区间修改</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree[p].l &gt; y || Tree[p].r &lt; x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= Tree[p].l &amp;&amp; Tree[p].r &lt;= y) &#123;</span><br><span class="line">        <span class="type">int</span> len = Tree[p].r - Tree[p].l + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Maketag</span>(p, len, k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Tree[p].lazy) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="built_in">add2</span>(p &lt;&lt; <span class="number">1</span>, x, y, k);</span><br><span class="line">    <span class="built_in">add2</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, y, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>区间查询</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree[p].l &gt; y || Tree[p].r &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= Tree[p].l &amp;&amp; Tree[p].r &lt;= y) &#123;</span><br><span class="line">        <span class="keyword">return</span> Tree[p].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Tree[p].lazy) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getsum2</span>(p &lt;&lt; <span class="number">1</span>, x, y) + <span class="built_in">getsum2</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态开点">动态开点</h3><h4 id="模板这里以维护最大值为例">模板(这里以维护最大值为例)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz[MAX_N], tot=<span class="number">1</span>;<span class="comment">//tot是当前使用的点的个数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> lazy;</span><br><span class="line">&#125;Tree[MAX_N];</span><br></pre></td></tr></table></figure><p><strong>左右节点求最大</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    Tree[p].val=<span class="built_in">max</span>(Tree[Tree[p].l].val , Tree[Tree[p].r].val);<span class="comment">//需要修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>懒标记</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Maketag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Tree[p].lazy +=x;</span><br><span class="line">    Tree[p].val += x;<span class="comment">//重点修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>下传懒标记</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree[p].l == <span class="number">-1</span>)Tree[p].l = ++tot;<span class="comment">//没有左儿子就“生”一个</span></span><br><span class="line">    <span class="keyword">if</span>(Tree[p].r == <span class="number">-1</span>)Tree[p].r = ++tot;<span class="comment">//没有右儿子就“生”一个</span></span><br><span class="line">    <span class="keyword">if</span>(Tree[p].val)&#123;</span><br><span class="line">        <span class="comment">// int M = (Tree[p].r+Tree[p].l )&gt;&gt; 1;</span></span><br><span class="line">        <span class="built_in">Maketag</span>(Tree[p].l, Tree[p].lazy);</span><br><span class="line">        <span class="built_in">Maketag</span>(Tree[p].r, Tree[p].lazy);</span><br><span class="line">        Tree[p].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>区间修改(同模版)</strong></p><p><strong>查询区间最大值</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; y || r &lt;x) <span class="keyword">return</span> <span class="number">-1e9</span>;<span class="comment">//重点初始化易错</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>附上例题 <ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=j">数列操作(加强版)</a></p></blockquote><h3 id="例题-1">例题</h3><table><colgroup><col style="width: 26%" /><col style="width: 40%" /><col style="width: 33%" /></colgroup><thead><tr><th>题目</th><th>方法</th><th>易错点</th></tr></thead><tbody><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=a">a.数列操作</a></td><td>修改<code>Maketag</code> , <code>pushup</code> ,<code>getsum</code></td><td>初始化应该为1e9</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=b">b.涂色</a></td><td><code>val</code>用来维护当前区间被涂色的数量</td><td></td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=e">e.小白逛公园</a></td><td>用<code>maxs</code> 维护最大字段和</td><td>多个值的维护方式</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=f">F- 【USACO NOV08 GOLD】开关灯</a></td><td>通过异或来维护灯的开关,Tree[p].val维护的是亮着的灯的数量</td><td>当前亮 = 总共 - 之前亮</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=m">m.区间连续值</a></td><td>与e相似,可以将0直接赋值为-1e6,求出最大子段和即为答案</td><td>如果求出来小于0直接输出0</td></tr><tr><td><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3125&amp;tid=g">g.蒟蒻的数列</a></td><td>核心在于使用动态开点进行处理</td><td>题目中所求区间是<span class="math inline">\([a,b)\)</span></td></tr></tbody></table><h2 id="算法对比">算法对比</h2><table style="width:100%;"><colgroup><col style="width: 4%" /><col style="width: 37%" /><col style="width: 37%" /><col style="width: 21%" /></colgroup><thead><tr><th>算法</th><th>优点</th><th>缺点</th><th>时间复杂度（预处理/单次查询或修改）</th></tr></thead><tbody><tr><td>ST表</td><td>预处理简单，查询速度快，适合静态数据</td><td>无法动态更新数据，预处理占用较多空间</td><td><span class="math inline">\(O(n \log n)\)</span> / <spanclass="math inline">\(O(1)\)</span></td></tr><tr><td>LCA</td><td>适用于树结构中的最近公共祖先问题，查询速度快</td><td>需要构建树结构，不适用于其他类型的查询</td><td><span class="math inline">\(O(n \log n)\)</span> / <spanclass="math inline">\(O(\log n)\)</span></td></tr><tr><td>线段树</td><td>支持动态更新和区间查询，功能强大</td><td>实现复杂，占用空间较大，预处理时间较长</td><td><span class="math inline">\(O(n)\)</span> / <spanclass="math inline">\(O(\log n)\)</span></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论笔记</title>
      <link href="/2025/03/12/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/12/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[这是一篇基础数论的笔记,由ny_123457提供<button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><h1 id="基础数论第二版">基础数论（第二版）</h1><h3 id="原作者luogu-ny_123457">原作者：luogu ny_123457</h3><h2 id="part-1.排列组合">Part 1.排列组合</h2><h3 id="排列"><strong>排列</strong></h3><p>将 <span class="math inline">\(n\)</span>个不同的东西排成一排，问有多少种排法？</p><p>这是一个经典的排列问题，通常我们用 <spanclass="math inline">\(A^m_n\)</span> 表示从 <spanclass="math inline">\(n\)</span> 个物品中选 <spanclass="math inline">\(m\)</span>个的不同的排列方案，像上面那个问题的答案就是 <spanclass="math inline">\(A_n^n\)</span>。</p><p>计算公式为 <span class="math inline">\(A_n^m=\frac{n!}{(n-m)!}=n\cdot (n-1) \cdot (n-2) \cdot \dots \cdot (n-m+1)\)</span>。</p><p>特别地，当 <span class="math inline">\(m&gt;n\)</span> 时，<spanclass="math inline">\(A_n^m=0\)</span>。</p><h3 id="组合"><strong>组合</strong></h3><p>在 <span class="math inline">\(n\)</span> 个物品中选出 <spanclass="math inline">\(m\)</span> 个物品，问有多少种选法？</p><p>这是一个经典的求组合数的问题，我们可以用 <spanclass="math inline">\(C^m_n\)</span> 来表示在 <spanclass="math inline">\(n\)</span> 个物品中选出 <spanclass="math inline">\(m\)</span>个物品的方案数，即上面那个问题的答案。</p><p>计算公式为 <spanclass="math inline">\(C^m_n=\frac{A_n^m}{m!}=\frac{n!}{m! \cdot(n-m)!}\)</span>。当然，组合数也有递推公式，<spanclass="math inline">\(C_i^j=C_{i-1}^{j-1}+C_{i-1}^{j}\)</span>，此公式的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="part-2.隔板法">Part 2.隔板法</h2><p>有 <span class="math inline">\(n\)</span> 个物品，现在要将这 <spanclass="math inline">\(n\)</span> 个物品分成 <spanclass="math inline">\(m\)</span>组，每组至少有一个物品，问有多少种方案？</p><p>对于上面那个问题，我们可以设这 <span class="math inline">\(n\)</span>个物品排成一行，每相邻两个物品中间都有一个空隙，然后我们有 <spanclass="math inline">\(m-1\)</span>个板子，将这些板子插入空隙，每个空隙都只能插一个板子，板子一共有 <spanclass="math inline">\(C^{m-1}_{n-1}\)</span>种插法，上面那个问题的答案也是如此。</p><p><strong>一个很重要的变式</strong></p><p>假设现在有一个点在数轴的原点上，它要走到点 <spanclass="math inline">\(x\)</span> 上，但它必需走 <spanclass="math inline">\(n(x \leq n)\)</span>步，每步能向左或向右走且只能走一个单位长度，问它有多少种方案能使它走到点<span class="math inline">\(x\)</span> 上？</p><p>这个问题我们暂且可以称它为乱窜的点，如果这个点一直向终点方向走那么只需要走<span class="math inline">\(x\)</span> 步，也就是说一共有 <spanclass="math inline">\(x-1\)</span>个空隙，但没规定第一步只能向右走，也没规定走到终点时步数没用完就不能动，所以一共有<span class="math inline">\(x+1\)</span>个空隙。同时可以发现一个性质，这个点向左走一步之后又向右走一步相当于没有走，但剩余步数减少了两步，利用这个性质我们就可以知道板子的数量为<span class="math inline">\(\frac{n-x}{2}\)</span>。</p><p>最后这个问题的答案为 <spanclass="math inline">\(C_n^{\frac{n-x}{2}}\)</span>。</p><h2 id="part-3.卢卡斯定理lucas">Part 3.卢卡斯定理（lucas）</h2><p>卢卡斯定理用于求解大组合数取模的问题，其中模数必须为质数。正常的组合数运算可以通过递推公式求解，但当问题规模很大，而模数是一个不大的质数的时候，就不能简单地通过递推求解来得到答案，需要用到卢卡斯定理。</p><p>卢卡斯定理的具体内容是对于所有的质数 <spanclass="math inline">\(p\)</span> 有 <span class="math inline">\(C_n^m\bmod p=C_{n/p}^{m/p} \cdot C_{n \bmod p}^{m \bmod p} \bmodp\)</span>。<strong>注意：<span class="math inline">\(p\)</span>是个质数且范围不能太大。</strong></p><p>特别地，当 <span class="math inline">\(m=0\)</span> 时返回 <spanclass="math inline">\(1\)</span>。</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Lucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> m, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">C</span>(n % p, m % p, p) * <span class="built_in">Lucas</span>(n / p, m / p, p)) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="part-4.杨辉三角">Part 4.杨辉三角</h2><p>杨辉三角又称帕斯卡三角，它的每一个数都是组合数，每一个数都等于上一行中这个位置左右两边的数之和，没有的就记为<span class="math inline">\(0\)</span>。</p><p><ahref="https://cdn.luogu.com.cn/upload/image_hosting/35seocdu.png?x-oss-process=image/resize,m_lfit,h_170,w_225">这张图片</a>中所呈现的就是杨辉三角。</p><h3 id="杨辉三角的性质">杨辉三角的性质</h3><ol type="1"><li>杨辉三角中第 <span class="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的数就是 <spanclass="math inline">\(C(i,j)\)</span>。</li><li>杨辉三角有一定的对称性，即 <spanclass="math inline">\(C(i,j)=C(i,i-j)\)</span>。</li><li>杨辉三角的每一行对应于二项式展开的系数。例如 <spanclass="math inline">\((a+b)^n\)</span>的展开式中各项的系数就是杨辉三角的第 $ n$ 行。</li></ol><h2 id="part-5.斯特林数">Part 5.斯特林数</h2><h3 id="第二类斯特林数">第二类斯特林数</h3><p>（先别急着问为什么先讲第二类）</p><p>第二类斯特林数表示讲 <span class="math inline">\(n\)</span>个两两不同的元素，划分为 <span class="math inline">\(k\)</span>个互不区分的非空子集的方案数，可记作 <spanclass="math inline">\(S(n,k)\)</span>。</p><p>其递推表达式为：<span class="math inline">\(S(n,k)=S(n-1,k-1)+k \cdotS(n-1,k)\)</span>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">f[i][j]=(f[i<span class="number">-1</span>][j]*j+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一类斯特林数">第一类斯特林数</h3><p>第一类斯特林数是在第二类斯特林数的基础上加了一个条件：每个子集除了非空之外轮换也算作一种方案，即<span class="math inline">\([A,B,C,D]\)</span> 等价于 <spanclass="math inline">\([D,C,B,A]\)</span> 但不等价于 <spanclass="math inline">\([A,C,B,D]\)</span>，第一类斯特林数可以表示为 <spanclass="math inline">\(s(n,k)\)</span>。</p><p>其递推表达式为：<span class="math inline">\(s(n,k)=s(n-1,k-1)+(n-1)\cdot s(n-1,k)\)</span>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i&amp;&amp;j&lt;=m;j++)&#123;</span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j<span class="number">-1</span>]+(i<span class="number">-1</span>)*s[i<span class="number">-1</span>][j]%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="part-6.例题">Part 6.例题</h2><h3 id="例题-1">例题 1</h3><h4 id="题目描述">题目描述</h4><p>计算 <span class="math inline">\(C(n,m) \bmod p\)</span>，其中 <spanclass="math inline">\(p\)</span> 是质数且 <spanclass="math inline">\(1&lt;p&lt;10^6\)</span>，<spanclass="math inline">\(1 \le m \le n \le 10^6\)</span>。</p><h4 id="解析">解析</h4><p>从题目描述中很容易就能看出是卢卡斯定理，但是这里让我们计算 <spanclass="math inline">\(C(n,m)\)</span>就可以知道需要用到快速幂，而且这个题需要计算多个组合数，所以就可以直接公式套出组合数，然后就是直接套卢卡斯定理的公式了（这里数据范围不是很大，因此处理一些像<span class="math inline">\(n=p\)</span>的特殊情况没那么麻烦，至于数据大一点这个代码就可能要跑很久，这里就不给出数据太大的做法）。</p><h4 id="参考代码">参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1ll</span>)res=res*x%mod;</span><br><span class="line">x=x*x%mod;</span><br><span class="line">y&gt;&gt;=<span class="number">1ll</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_comb</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">a=a*i%p;</span><br><span class="line"><span class="keyword">if</span>(i==y)b=a;</span><br><span class="line"><span class="keyword">if</span>(i==x-y)c=a;</span><br><span class="line">&#125;</span><br><span class="line">b=<span class="built_in">ksm</span>(b,p<span class="number">-2</span>,p);</span><br><span class="line">c=<span class="built_in">ksm</span>(c,p<span class="number">-2</span>,p);</span><br><span class="line"><span class="keyword">return</span> a*b%p*c%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;y||x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;p)<span class="keyword">return</span> <span class="built_in">get_comb</span>(x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">lucas</span>(x%p,y%p)*<span class="built_in">lucas</span>(x/p,y/p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">cout&lt;&lt;<span class="built_in">lucas</span>(n,m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2">例题 2</h3><h4 id="题目描述-1">题目描述</h4><p>何老板打算在 NK 食堂办酒席，宴请信竞队队员。信竞队共有 <spanclass="math inline">\(n\)</span> 名队员，编号 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span>，大家都很想参加宴会。但何老板只邀请其中<span class="math inline">\(r\)</span> 个队员。他要你帮他选出 <spanclass="math inline">\(r\)</span>名队员，要求选出的这些队员的编号差必须大于等于 <spanclass="math inline">\(k\)</span>（任意两人都要大于等于 <spanclass="math inline">\(k\)</span>）。<br />然后由你来预订酒桌和安排队员们就座。何老板要求酒桌的数量不超过 <spanclass="math inline">\(m\)</span>，每桌至少坐 <spanclass="math inline">\(1\)</span>人。何老板想知道，总共有多少种不同的方案？</p><h4 id="解析-1">解析</h4><p>从题目不难看出是第二类斯特林数加动态规划，具体的解请看代码里的注释，这里就不再多说了。</p><h4 id="参考代码-1">参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n,m,r,k,ans,f[<span class="number">1005</span>][<span class="number">1005</span>],dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="comment">//$dp_&#123;i,j&#125;$ 表示前 $i$ 个人中选 $j$ 个人的情况。</span></span><br><span class="line"><span class="comment">//$f_&#123;i,j&#125;$ 表示第一类斯特林数 </span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;r&gt;&gt;k&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][<span class="number">1</span>]=i;<span class="comment">//只选一个人有 $i$ 种情况 </span></span><br><span class="line">dp[i][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//一个人也不选也是一种情况 </span></span><br><span class="line">&#125;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">+1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">dp[i][j]=(dp[i-k][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">f[i][j]=(f[i<span class="number">-1</span>][j]*j%mod+f[i<span class="number">-1</span>][j<span class="number">-1</span>]%mod)%mod;</span><br><span class="line"><span class="comment">//左:选,右:不选  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">ans=ans+f[r][j];<span class="comment">//$1$ 到 $m$ 的桌子情况数 </span></span><br><span class="line">ans=ans%mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans*dp[n][r]%mod;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完结撒花">完结撒花！</h2><p><del>最后致敬那个天天请客的何老板。</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder better与codefouces better安装方法</title>
      <link href="/2025/03/01/Atcoder-better%E4%B8%8Ecodefouces-better%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"/>
      <url>/2025/03/01/Atcoder-better%E4%B8%8Ecodefouces-better%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这是hcz写的atcoder-better安装教程</p><button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><h2 id="注意">注意</h2><p><strong>本版本为hcz特制,仅限南渝信竞班自用</strong></p><h2id="第一步安装篡改猴如已经安装请跳过">第一步,安装篡改猴(如已经安装请跳过)</h2><h3 id="edge">edge</h3><p>1.打开插件市场或点<ahref="https://microsoftedge.microsoft.com/addons/detail/%E7%AF%A1%E6%94%B9%E7%8C%B4/iikmkjmpaadaobahmlepeloendndfphd">我</a><br /><img src="/img/050225/2.jpg" /><br />2.搜索篡改猴并安装 <img src="/img/050225/3.jpg" /></p><h3 id="chrome">chrome</h3><p><ahref="https://hczwp2.胡.fun/d/tywebnew/tampermonkey_legacy.rar?sign=5AMacCXWbEwApmgFG0K9ZZuUMH0fMP2e_6OwvpC5UNE=:0">篡改猴chrome edge 等下载</a></p><p>视频教程<br /><ahref="https://hczwp2.xn--920a.fun/d/tywebnew/4.mp4?sign=I_ujSKdL4884teTxiKRKwFP4X2z3cAJcirVNk4YinLw=:0">下载视频教程</a></p><p>下载压缩包后解压缩<br /><img src="/img/050225/1.PNG" /><br />在设置中找到拓展程序<br /><img src="/img/050225/5.jpg" /><br />打开开发者模式,选择已解压缩的拓展-&gt;选择已经解压的文件夹,注意是最里面的一层</p><h3 id="firefox">firefox</h3><p>最简单,点链接安装<br /><ahref="https://cdl.胡.fun/dl/https://addons.mozilla.org/firefox/downloads/file/4405733/tampermonkey-5.3.3.xpi">篡改猴firefox</a></p><h2 id="第二步安装脚本点击下方按钮">第二步,安装脚本,点击下方按钮</h2><p><a href="/better/atcoder.user.js">Atcoder better</a><br /><a href="/better/codeforce.user.js">codefouce better</a></p><p>点击安装即可(点击后要等待一会,初次安装进入atcoder需要等待一会)</p><p><img src="/img/050225/6.jpg" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周赛2小结</title>
      <link href="/2024/12/02/%E5%91%A8%E8%B5%9B2%E5%B0%8F%E7%BB%93/"/>
      <url>/2024/12/02/%E5%91%A8%E8%B5%9B2%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这是hcz写的周赛2小结</p><button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><h1 id="周赛2小结"><ahref="https://vjudge.net/contest/675092">周赛2</a>小结</h1><h2 id="a---卡牌游戏"><ahref="https://vjudge.net/contest/675092#problem/A">A - 卡牌游戏</a></h2><p>这道题是纯模拟，</p><p>没什么要点，按照题目模拟即可</p><h2 id="b---卡牌"><ahref="https://vjudge.net/contest/675092#problem/B">B - 卡牌</a></h2><p>这道题是<span class="math inline">\(DP\)</span></p><p><strong>初始化:</strong> <spanclass="math inline">\(f[0][5000]=1\)</span></p><p><strong>分析：</strong></p><p><span class="math inline">\(f[i][j]\)</span>表示在<spanclass="math inline">\(b\)</span>数组中选择一些方案数使总和为<spanclass="math inline">\(j\)</span></p><p><strong>状态转移方程：</strong></p><p>当<span class="math inline">\(j &gt;=x_{i}\)</span> : <spanclass="math inline">\(f[i][j]=f[i-1][j]\)</span></p><p>当<span class="math inline">\(j&lt;x_{i}\)</span> : <spanclass="math inline">\(f[i][j]=f[i-1][j]+f[i-1][j-x_{i}]\)</span></p><h6 id="样例3分析如下图">样例3分析，如下图</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 5</span><br><span class="line">3 6 2 8 7 6 5 9</span><br></pre></td></tr></table></figure><p><img title="" src="data:image/png;base64,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" alt="" width="670"></p><p><strong>伪代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>--n)&#123;</span><br><span class="line">    <span class="keyword">for</span>(-sum<span class="number">+5000</span>--sum<span class="number">+5000</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= x[i])&#123;<span class="comment">// 两种情况</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] + f[i<span class="number">-1</span>][j-x[i]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n][<span class="number">5000</span>] - <span class="number">1</span> &gt; <span class="number">0</span> ? f[n][<span class="number">5000</span>] - <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 最后输出f[n][5000]-1 ，因为在最开始多了一种方案不选，所以输出要-1</span></span><br></pre></td></tr></table></figure><h2 id="c---表达式"><ahref="https://vjudge.net/contest/675092#problem/C">C - 表达式</a></h2><p><span class="math inline">\(|s|&lt;=10\)</span></p><p>此题数据较小，<span class="math inline">\(DFS\)</span>就能过</p><p>可以用<code>substr</code>和<code>stoi</code>函数简化过程</p><h2 id="d---网格涂色"><ahref="https://vjudge.net/contest/675092#problem/D">D - 网格涂色</a></h2><p>这道题是一道思维题，当你每涂黑一块，以它为中心的<spanclass="math inline">\(3 ×3\)</span>的数所在的九宫格都会<spanclass="math inline">\(+1\)</span>，如图</p><p><img src="data:image/png;base64,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" title="" alt="" width="271"></p><p>而在计算时要注意中心点可以在的范围，<span class="math inline">\(x&gt; 1\)</span> &amp;&amp; <span class="math inline">\(x &lt; h\)</span>&amp;&amp; <span class="math inline">\(y &gt; 1\)</span> &amp;&amp;<span class="math inline">\(y &lt; w\)</span></p><p>注意最后计算<span class="math inline">\(ans[0]=(h-2)(w-2)-ans[1 \to9]\)</span></p><p>伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>--n)&#123;</span><br><span class="line">        <span class="comment">//输入a, b</span></span><br><span class="line">        <span class="keyword">for</span>(j:<span class="number">-1</span>-<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(k:<span class="number">-1</span>-<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> x = a+j,y = b+k;</span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">1</span> &amp;&amp; x &lt; h &amp;&amp; y &gt; <span class="number">1</span> &amp;&amp; y &lt; w)&#123;</span><br><span class="line"></span><br><span class="line">                    now = ++mp[&#123;x, y&#125;];</span><br><span class="line">                    ans[now]++;</span><br><span class="line">                    ans[now<span class="number">-1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 处理部分</span></span><br></pre></td></tr></table></figure><h2 id="e---数字"><ahref="https://vjudge.net/contest/675092#problem/E">E - 数字</a></h2><p>先简化题意，函数<span class="math inline">\(f(b,n)\)</span>代表求n的b进制的各位数字之和，要确定最小的数字b使<spanclass="math inline">\(f(b, n)=s\)</span></p><h6 id="个特判">2个特判</h6><p><strong>1：</strong> 当<spanclass="math inline">\(n&lt;s\)</span>，输出<spanclass="math inline">\(-1\)</span></p><p>因为在任何进制下，数字的各位之和是不会大于 <code>n</code>的，所以不可能存在</p><p><strong>2：</strong> 当<spanclass="math inline">\(n=s\)</span>,输出<spanclass="math inline">\(n+1\)</span>，这个比较好理解，在<spanclass="math inline">\(n+1\)</span>进制，<spanclass="math inline">\(n\)</span>不变</p><h5 id="重点部分">重点部分</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ff</span>(i, n) == s ) ans = <span class="built_in">min</span>(ans, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要找到一个进制 b 使得 <spanclass="math inline">\(f(b,n)=s\)</span>，也就是说，找到一个进制b，使得在该进制下，数字<spanclass="math inline">\(n\)</span>的各位之和等于给定的 s。</p><p>当<span class="math inline">\(m&gt;\sqrt{n}\)</span>，转换后只有2位</p><p>$n=mx+y $<br />$ s=x+y $<br />$ n-s=(m-1)x $<br />$ m=(n-s) x+1$</p><p>所以，<span class="math inline">\(x\)</span>的范围<spanclass="math inline">\(1\)</span> ~ <spanclass="math inline">\(\sqrt{n-s}\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">sqrt</span>(n - s); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ff</span>((n - s) / i + <span class="number">1</span>, n) == s) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (n - s) / i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出注意long long</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans == LONG_LONG_MAX ? <span class="number">-1ll</span> : ans);</span><br></pre></td></tr></table></figure><h2 id="the-end-作者胡长治"><span class="math inline">\(The\)</span> ●<span class="math inline">\(end\)</span> 作者:<spanclass="math inline">\(胡长治\)</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 小结 </tag>
            
            <tag> hcz </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树总结</title>
      <link href="/2024/11/28/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%80%BB%E7%BB%93/"/>
      <url>/2024/11/28/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这是hcz写的最小生成树总结</p><button class="post-ai" id="summarize-button"><div class="spinner" style="display: none;"></div><img alt="Static Badge" src="/img/b.PNG" />愣着干嘛，看看AI摘要啊，点击后请等待，请不要重复点击</button><style type="text/css">.spinner{border:4px solid rgba(0,0,0,.1);width:20px;height:20px;border-radius:50%;border-left-color:#09f;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.markdown-body{padding:15px;background-color:#f9f9f9;border:1px solid #ddd;border-radius:5px;font-family:Arial,sans-serif;line-height:1.6}.markdown-body p{margin-bottom:10px}</style><script src="https://cdn.xn--920a.fun/dl/https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script>async function geminiAI(){const postAI=document.querySelector(".post-ai");const postTitleElement=document.querySelector(".post-title");const postContentElement=document.querySelector(".post-content");let spinner=document.querySelector(".spinner");if(!postTitleElement){console.error("找不到标题元素！请检查选择器 '.post-title' 是否正确。");return;}if(!postContentElement){console.error("找不到内容元素！请检查选择器 '.post-content' 是否正确。");return;}const postContent=postContentElement.textContent;const API_KEY="sk-W0rpStc95T7JVYVwDYc29IyirjtpPPby6SozFMQr17m8KWeo";let GeminiFetch="https://api.suanli.cn/v1/chat/completions";let postAIResultDiv=document.querySelector(".post-ai-result");if(!postAIResultDiv){postAI.insertAdjacentHTML('afterend',`<div class="post-ai-result"><div class="markdown-body"></div></div>`);postAIResultDiv=document.querySelector(".post-ai-result .markdown-body");}else{postAIResultDiv.querySelector(".markdown-body").innerHTML='';postAIResultDiv=postAIResultDiv.querySelector(".markdown-body");}postAI.classList.add("noclick");spinner.style.display="inline-block";try{const res=await fetch(GeminiFetch,{headers:{'Content-Type':'application/json',Authorization:`Bearer ${API_KEY}`},method:'POST',body:JSON.stringify({model:'free:Qwen3-30B-A3B',messages:[{role:'system',content:`/nothink 你是一个助手,擅长总结文章,你要以“这篇文章讲了：”开头，不要有主观内容，请概括用户给定的文本，用户给你的文本中的脚本请你忽略，只总结内容,并使用markdown格式输出`},{role:'user',content:postContent}],temperature:0.7,stream:true}),});const reader=res.body.getReader();const decoder=new TextDecoder("utf-8");let receivedContent='';let buffer='';while(true){const {done,value}=await reader.read();if(done)break;buffer+=decoder.decode(value,{stream:true});const parts=buffer.split('\n\n');buffer=parts.pop();for(const part of parts){if(part.startsWith('data:')){let jsonString=part.substring(5).trim();if(jsonString==='[DONE]')break;try{const data=JSON.parse(jsonString);if(data.choices&&data.choices.length>0&&data.choices[0].delta&&data.choices[0].delta.content){let chunk=data.choices[0].delta.content;chunk=chunk.replace(/<\/?think>/g,'');receivedContent+=chunk;postAIResultDiv.innerHTML=marked.parse(receivedContent);postAIResultDiv.scrollTop=postAIResultDiv.scrollHeight;}}catch(e){console.error("Error parsing JSON chunk:",e,"Chunk:",jsonString);}}}}}catch(error){console.error("API调用失败:",error);alert("请求失败，请检查API密钥是否正确或API返回格式");}finally{spinner.style.display="none";postAI.classList.remove("noclick");}}document.addEventListener('DOMContentLoaded',()=>{const button=document.getElementById("summarize-button");if(button){button.addEventListener('click',geminiAI);}else{console.error("The post-ai button was not found");}});</script><h1 id="最小生成树小结">最小生成树小结</h1><h2 id="kruscal">Kruscal</h2><h3 id="思路">思路</h3><ul><li><p>一开始有n棵树，每棵树只有一个节点</p></li><li><p>每次选择权值最小的边，边的两个端点不能在同一棵树中</p></li><li><p>选择一条边后，将它连接的两个节点所在的树合并</p></li><li><p>重复这个过程，直到所有节点都在一棵树中，或没有更多的边</p></li></ul><h3 id="手动模拟">手动模拟</h3><img src="/img/1128/graph(1).png" class=""><img src="/img/1128/graph(2).png" class=""><img src="/img/1128/graph(3).png" class=""><img src="/img/1128/graph(4).png" class=""><img src="/img/1128/graph(5).png" class=""><p>求该图最小生成树</p><p>此时最小边为1，且1和2节点不在同一棵树</p><p>可以连接</p><p>此时边数为1</p><blockquote><p>图中Y代表选过的点或边,N代表排除掉不满足条件的边</p></blockquote><p>此时最小边为3，且2和3节点不在同一棵树</p><p>可以连接</p><p>此时边数为2</p><p>此时最小边为4，但1和3节点在同一棵树</p><p>不可以连接</p><p>此时边数仍为2</p><p>此时最小边为5，且1和4节点不在同一棵树</p><p>可以连接</p><p>此时边数为3，达到n-1，如图便是该图的最小生成树</p><h3 id="实际操作中">实际操作中</h3><blockquote><p>使用并查集合并</p></blockquote><h3 id="模版">模版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gfa</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[i] == i ? i : fa[i] = <span class="built_in">gfa</span>(fa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">zf</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125;sz[<span class="number">11010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(zf x, zf y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//连接道路</span></span><br><span class="line">            sz[++m].a = i;</span><br><span class="line">            sz[m].b = j;</span><br><span class="line">            sz[m].c = a;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(sz<span class="number">+1</span>, sz<span class="number">+1</span>+m,cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;cnt&lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">gfa</span>(sz[i].a);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">gfa</span>(sz[i].b);</span><br><span class="line">        <span class="keyword">if</span>(x!= y)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            ans += sz[i].c;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br></pre></td></tr></table></figure><h3 id="列题">列题</h3><h5 id="模版题">模版题</h5><h4 id="丛林道路nkoj1228"><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3080&amp;tid=C">丛林道路nkoj1228</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    cin &gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt;c;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        cin &gt;&gt; d;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重点在于输入转换，其它同上方模版</span></span><br><span class="line">        sz[++m].a = a - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        sz[m].b = c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        sz[m].c = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思考题">思考题</h4><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=3080&amp;tid=E">nkoj极地网络</a></p><p>这道题重点在于思路部分，点的数量仅需<spanclass="math inline">\(P-S\)</span>条边</p><p>还有一个重点，在处理边时要运用勾股定理计算</p><p><span class="math inline">\(\sqrt{(x_{1}-x_{2}  )^{2}+(y_{1}-y_{2}  )^{2}}\)</span></p><p>代码重点部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=p;j++)&#123;</span><br><span class="line">            a[++c].x=i;</span><br><span class="line">            a[c].y=j;</span><br><span class="line">            <span class="comment">//边的处理</span></span><br><span class="line">            a[c].z=<span class="built_in">sqrt</span>(<span class="number">1.0</span>*(bb[i]-bb[j])*(bb[i]-bb[j])<span class="number">+1.0</span>*(b[i]-b[j])*(b[i]-b[j]));</span><br><span class="line">            <span class="keyword">if</span>(i==j) a[c].z=INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c为边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ta=<span class="built_in">fa</span>(a[i].x),tb=<span class="built_in">fa</span>(a[i].y);</span><br><span class="line">        <span class="keyword">if</span>(ta!=tb)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,a[i].z);</span><br><span class="line">            f[ta]=tb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==p-s) <span class="keyword">break</span>;<span class="comment">//注意变为p-s</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="prim">prim</h2><h3 id="思想">思想</h3><ul><li><p>一开始树上只有一个节点</p></li><li><p>选择与树距离最近的一个不在树上的节点，加入树中</p></li><li><p>反复执行，直到所有点都加入树中</p></li></ul><h3 id="代码lj版">代码（LJ版）</h3><img src="/img/1128/1.PNG" class=""><img src="/img/1128/2.PNG" class=""><img src="/img/1128/3.PNG" class=""><p>prim+堆在许多情况下比<span class="math inline">\(Kruscal\)</span>快<img src="/img/1128/4.PNG" class=""> 推荐用<span class="math inline">\(Kruscal\)</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小结 </tag>
            
            <tag> 算法 </tag>
            
            <tag> hcz </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
